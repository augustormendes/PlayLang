/*
 * generated by Xtext 2.23.0
 */
package br.ufscar.dc.compiladores.serializer;

import br.ufscar.dc.compiladores.playLang.Atribuicao;
import br.ufscar.dc.compiladores.playLang.Cena;
import br.ufscar.dc.compiladores.playLang.Declaracao;
import br.ufscar.dc.compiladores.playLang.Escolha;
import br.ufscar.dc.compiladores.playLang.Escolhas;
import br.ufscar.dc.compiladores.playLang.EventoGlobal;
import br.ufscar.dc.compiladores.playLang.Expressao;
import br.ufscar.dc.compiladores.playLang.ExpressaoAritmetica;
import br.ufscar.dc.compiladores.playLang.ExpressaoRelacional;
import br.ufscar.dc.compiladores.playLang.Fator;
import br.ufscar.dc.compiladores.playLang.FatorLogico;
import br.ufscar.dc.compiladores.playLang.Game;
import br.ufscar.dc.compiladores.playLang.If;
import br.ufscar.dc.compiladores.playLang.Imagem;
import br.ufscar.dc.compiladores.playLang.Parcela;
import br.ufscar.dc.compiladores.playLang.Parcela_logica;
import br.ufscar.dc.compiladores.playLang.PlayLangPackage;
import br.ufscar.dc.compiladores.playLang.PlaySound;
import br.ufscar.dc.compiladores.playLang.Random;
import br.ufscar.dc.compiladores.playLang.Termo;
import br.ufscar.dc.compiladores.playLang.TermoLogico;
import br.ufscar.dc.compiladores.playLang.Texto;
import br.ufscar.dc.compiladores.services.PlayLangGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PlayLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PlayLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PlayLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PlayLangPackage.ATRIBUICAO:
				sequence_Atribuicao(context, (Atribuicao) semanticObject); 
				return; 
			case PlayLangPackage.CENA:
				sequence_Cena(context, (Cena) semanticObject); 
				return; 
			case PlayLangPackage.DECLARACAO:
				sequence_Declaracao(context, (Declaracao) semanticObject); 
				return; 
			case PlayLangPackage.ESCOLHA:
				sequence_Escolha(context, (Escolha) semanticObject); 
				return; 
			case PlayLangPackage.ESCOLHAS:
				sequence_Escolhas(context, (Escolhas) semanticObject); 
				return; 
			case PlayLangPackage.EVENTO_GLOBAL:
				sequence_EventoGlobal(context, (EventoGlobal) semanticObject); 
				return; 
			case PlayLangPackage.EXPRESSAO:
				sequence_Expressao(context, (Expressao) semanticObject); 
				return; 
			case PlayLangPackage.EXPRESSAO_ARITMETICA:
				sequence_ExpressaoAritmetica(context, (ExpressaoAritmetica) semanticObject); 
				return; 
			case PlayLangPackage.EXPRESSAO_RELACIONAL:
				sequence_ExpressaoRelacional(context, (ExpressaoRelacional) semanticObject); 
				return; 
			case PlayLangPackage.FATOR:
				sequence_Fator(context, (Fator) semanticObject); 
				return; 
			case PlayLangPackage.FATOR_LOGICO:
				sequence_FatorLogico(context, (FatorLogico) semanticObject); 
				return; 
			case PlayLangPackage.GAME:
				sequence_Game(context, (Game) semanticObject); 
				return; 
			case PlayLangPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case PlayLangPackage.IMAGEM:
				sequence_Imagem(context, (Imagem) semanticObject); 
				return; 
			case PlayLangPackage.PARCELA:
				sequence_Parcela(context, (Parcela) semanticObject); 
				return; 
			case PlayLangPackage.PARCELA_LOGICA:
				sequence_Parcela_logica(context, (Parcela_logica) semanticObject); 
				return; 
			case PlayLangPackage.PLAY_SOUND:
				sequence_PlaySound(context, (PlaySound) semanticObject); 
				return; 
			case PlayLangPackage.RANDOM:
				sequence_Random(context, (Random) semanticObject); 
				return; 
			case PlayLangPackage.TERMO:
				sequence_Termo(context, (Termo) semanticObject); 
				return; 
			case PlayLangPackage.TERMO_LOGICO:
				sequence_TermoLogico(context, (TermoLogico) semanticObject); 
				return; 
			case PlayLangPackage.TEXTO:
				sequence_Texto(context, (Texto) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Comando returns Atribuicao
	 *     Atribuicao returns Atribuicao
	 *
	 * Constraint:
	 *     (id=[Declaracao|ID] (expressao=Expressao | string=STRING))
	 */
	protected void sequence_Atribuicao(ISerializationContext context, Atribuicao semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cena returns Cena
	 *
	 * Constraint:
	 *     (name=ID textos+=Texto+ imagem=Imagem? sound=PlaySound? escolhas+=Escolhas+)
	 */
	protected void sequence_Cena(ISerializationContext context, Cena semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaracao returns Declaracao
	 *
	 * Constraint:
	 *     (tipo=Tipo name=ID (string=STRING | bool=BOOL | int=INT | zero='ZERO'))
	 */
	protected void sequence_Declaracao(ISerializationContext context, Declaracao semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Escolha returns Escolha
	 *
	 * Constraint:
	 *     (textos+=Texto+ comando+=Comando* (if=If | id=[Cena|ID]))
	 */
	protected void sequence_Escolha(ISerializationContext context, Escolha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Escolhas returns Escolhas
	 *
	 * Constraint:
	 *     (singleChoice=Escolha | (hasIf?='IF' expressaoIf=Expressao escolhasIF+=Escolhas+ (hasElse?='ELSE' escolhasELSE+=Escolhas+)?))
	 */
	protected void sequence_Escolhas(ISerializationContext context, Escolhas semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EventoGlobal returns EventoGlobal
	 *
	 * Constraint:
	 *     comandos+=Comando+
	 */
	protected void sequence_EventoGlobal(ISerializationContext context, EventoGlobal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressaoAritmetica returns ExpressaoAritmetica
	 *
	 * Constraint:
	 *     (termos+=Termo (op+=OP1 termos+=Termo)*)
	 */
	protected void sequence_ExpressaoAritmetica(ISerializationContext context, ExpressaoAritmetica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressaoRelacional returns ExpressaoRelacional
	 *
	 * Constraint:
	 *     (expressoes+=ExpressaoAritmetica (op+=OPRELACIONAL expressoes+=ExpressaoAritmetica)*)
	 */
	protected void sequence_ExpressaoRelacional(ISerializationContext context, ExpressaoRelacional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expressao returns Expressao
	 *
	 * Constraint:
	 *     (termos+=TermoLogico (ou+=OU termos+=TermoLogico)*)
	 */
	protected void sequence_Expressao(ISerializationContext context, Expressao semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FatorLogico returns FatorLogico
	 *
	 * Constraint:
	 *     (nao?=NAO? parcela=Parcela_logica)
	 */
	protected void sequence_FatorLogico(ISerializationContext context, FatorLogico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fator returns Fator
	 *
	 * Constraint:
	 *     (parcelas+=Parcela (op+='%' parcelas+=Parcela)*)
	 */
	protected void sequence_Fator(ISerializationContext context, Fator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Game returns Game
	 *
	 * Constraint:
	 *     (linha=INT coluna=INT declaracoes_globais+=Declaracao* evento=EventoGlobal? cenas+=Cena*)
	 */
	protected void sequence_Game(ISerializationContext context, Game semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     If returns If
	 *
	 * Constraint:
	 *     (expressaoIf=Expressao idIf=[Cena|ID] (elif=If | idElse=[Cena|ID]))
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Imagem returns Imagem
	 *
	 * Constraint:
	 *     (caminho=STRING (linha=INT coluna=INT)?)
	 */
	protected void sequence_Imagem(ISerializationContext context, Imagem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parcela returns Parcela
	 *
	 * Constraint:
	 *     (sub?='-'? (id=[Declaracao|ID] | int=INT))
	 */
	protected void sequence_Parcela(ISerializationContext context, Parcela semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parcela_logica returns Parcela_logica
	 *
	 * Constraint:
	 *     (p=BOOL | exp=ExpressaoRelacional)
	 */
	protected void sequence_Parcela_logica(ISerializationContext context, Parcela_logica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PlaySound returns PlaySound
	 *
	 * Constraint:
	 *     file_path=STRING
	 */
	protected void sequence_PlaySound(ISerializationContext context, PlaySound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlaySoundAccess().getFile_pathSTRINGTerminalRuleCall_2_0(), semanticObject.getFile_path());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Comando returns Random
	 *     Random returns Random
	 *
	 * Constraint:
	 *     (
	 *         id=[Declaracao|ID] 
	 *         (
	 *             (possibilidadesInt+=INT possibilidadesInt+=INT*) | 
	 *             (possibilidadesString+=STRING possibilidadesString+=STRING*) | 
	 *             (possibilidadesBool+=BOOL possibilidadesBool+=BOOL*)
	 *         )
	 *     )
	 */
	protected void sequence_Random(ISerializationContext context, Random semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermoLogico returns TermoLogico
	 *
	 * Constraint:
	 *     (fatores+=FatorLogico (e+=E fatores+=FatorLogico)*)
	 */
	protected void sequence_TermoLogico(ISerializationContext context, TermoLogico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Termo returns Termo
	 *
	 * Constraint:
	 *     (fatores+=Fator (op+=OP2 fatores+=Fator)*)
	 */
	protected void sequence_Termo(ISerializationContext context, Termo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Texto returns Texto
	 *
	 * Constraint:
	 *     (text=STRING | var=[Declaracao|ID])
	 */
	protected void sequence_Texto(ISerializationContext context, Texto semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
