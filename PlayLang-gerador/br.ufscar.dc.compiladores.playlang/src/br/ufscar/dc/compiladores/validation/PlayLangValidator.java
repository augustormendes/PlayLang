/*
 * generated by Xtext 2.23.0
 */
package br.ufscar.dc.compiladores.validation;

import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;

import br.ufscar.dc.compiladores.playLang.Atribuicao;
import br.ufscar.dc.compiladores.playLang.Cena;
import br.ufscar.dc.compiladores.playLang.Declaracao;
import br.ufscar.dc.compiladores.playLang.Expressao;
import br.ufscar.dc.compiladores.playLang.ExpressaoAritmetica;
import br.ufscar.dc.compiladores.playLang.ExpressaoRelacional;
import br.ufscar.dc.compiladores.playLang.Game;
import br.ufscar.dc.compiladores.playLang.Imagem;
import br.ufscar.dc.compiladores.playLang.Parcela_logica;
import br.ufscar.dc.compiladores.playLang.PlayLangPackage;
import br.ufscar.dc.compiladores.playLang.PlaySound;
import br.ufscar.dc.compiladores.playLang.Random;
import br.ufscar.dc.compiladores.playLang.Termo;
import br.ufscar.dc.compiladores.playLang.TermoLogico;
import br.ufscar.dc.compiladores.playLang.impl.AtribuicaoImpl;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class PlayLangValidator extends AbstractPlayLangValidator {
	

	@Check 
	
	public void checkAudio(PlaySound sound) {
		File f = new File(sound.getFile_path());
		//Checa se o caminho dado corresponde a um arquivo existente
		if(!f.exists()) {
			error("Arquivo não existe",PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH);
			return;
		}

			AudioInputStream stream;
			try {
				stream = AudioSystem.getAudioInputStream(f);
				Clip audio = AudioSystem.getClip();
				audio.open(stream);
			} catch (UnsupportedAudioFileException e) {
				error("Formato de arquivo não suportado. São aceitos os formatos AIFC, AIFF, AU, SND e WAVE",PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH);
				
			} catch (LineUnavailableException e) {
				error("Dispositivo de áudio indisponível",PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH);
				
			} catch (IOException e) {
				error("Falha ao abrir arquivo",PlayLangPackage.Literals.PLAY_SOUND__FILE_PATH);
				
			}
			
			

	} 
	
	
	@Check
	
	public void checkImage(Imagem imagem) {
		File f = new File(imagem.getCaminho());
		//Checa se o caminho dado corresponde a um arquivo existente
		if(!f.exists()) {
			error("Arquivo não existe",PlayLangPackage.Literals.IMAGEM__CAMINHO);
			return;
		}
		try {
			//Checa se o arquivo é de fato uma imagem
			if(ImageIO.read(f) == null) {
				error("Arquivo não é uma imagem",PlayLangPackage.Literals.IMAGEM__CAMINHO);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	@Check
	public void checkDeclarationType(Declaracao declaracao) {
	
		//Checa se a declaração correnponde aos tipos declarados
		if(declaracao.getTipo().equals("STRING") && declaracao.getString() == null) {
			error("Valor da variável deve ser string", PlayLangPackage.Literals.DECLARACAO__STRING);
			return;
		}
		if(declaracao.getTipo().equals("INT") && declaracao.getInt() == 0 && declaracao.getZero()==null ) {
			error("Valor da variável deve ser inteiro", PlayLangPackage.Literals.DECLARACAO__INT);
			return;
		}
		if(declaracao.getTipo().equals("BOOL") && declaracao.getBool() == null ) {
			error("Valor da variável deve ser inteiro", PlayLangPackage.Literals.DECLARACAO__BOOL);
		}
	}
	@Check
	//checa se uma variável não foi declarada antes
	public void checkIfAlreadyDeclared(Declaracao declaracao) {
	  Game game = (Game)declaracao.eContainer();
	  EList<Declaracao> declaracoes = game.getDeclaracoes_globais();
	  String name = declaracao.getName();
	  for(var decl:declaracoes) {
		//Se esta foi a primeira vez que a variável foi declarada, ela não deve ser declarada errada
		  if(decl == declaracao) break; 
		  if(decl.getName().equals(name)) {
			  error("Variável já declarada",PlayLangPackage.Literals.DECLARACAO__NAME);
		  }
		 
	  }
	}
	@Check
	//checa se uma cena não foi declarada antes
	public void checkIfAlreadyDeclared(Cena cena) {
	  Game game = (Game)cena.eContainer();
	  EList<Cena> declaracoes = game.getCenas();
	  String name = cena.getName();
	  for(var decl:declaracoes) {
		//Se esta foi a primeira vez que a cena foi declarada, ela não deve ser declarada errada
		  if(decl == cena) break; 
		  if(decl.getName().equals(name)) {
			  error("Cena já declarada",PlayLangPackage.Literals.CENA__NAME);
		  }
		 
	  }
	}
	
	
	@Check
	
	public String checkRExpressionType(ExpressaoRelacional expressaoR) {
		boolean singleExpression = false;
		if(expressaoR.getExpressoes().size() == 1) {
			if(expressaoR.getExpressoes().get(0).getTermos().size() ==1) {
				if(expressaoR.getExpressoes().get(0).getTermos().get(0).getFatores().size() == 1) {
					if(expressaoR.getExpressoes().get(0).getTermos().get(0).getFatores().get(0).getParcelas().size() == 1) {
						singleExpression = true;
					}
				}
			}
		}
		for(var expressao:expressaoR.getExpressoes()) {
		for(var termo:expressao.getTermos()) {
			for(var fator:termo.getFatores()) {
				for(var parcela:fator.getParcelas()) {		
						if(parcela.getId() != null) {
							//Se o identificador tiver tipo string ele não pode ser parte de uma expressão relacional
							//Exceção para o caso de atribuicão 
							if(parcela.getId().getTipo().equals("STRING")  ) {
								if(!(singleExpression && (expressaoR.eContainer().eContainer().eContainer() instanceof AtribuicaoImpl  ||expressaoR.eContainer().eContainer().eContainer().eContainer().eContainer() instanceof AtribuicaoImpl ))) {
									error("Expressão relacional contém string",parcela,PlayLangPackage.Literals.PARCELA__ID);
									return "INVALIDO";
								}
								else return "STRING";
							}
							//Se o identificador tiver tipo bool ele deve ser o único termo da expressão relacional
							if(parcela.getId().getTipo().equals("BOOL") ) {
								if(singleExpression) return "BOOL";
								else{
									error("Expressão relacional contém booleano",parcela,PlayLangPackage.Literals.PARCELA__ID);
									return "INVALIDO";
									}
							}
							
						
						
						
				}
			}
		}
		}
		
	}
		//Se há mais de uma expressão aritmética numa expressão relacional, o tipo dela será bool
		if(expressaoR.getExpressoes().size()>1) return "BOOL";
		//Senão, será int
		else return "INT";
	}
	@Check
	public void CheckRandomCommand(Random random) {
		String tipo = random.getId().getTipo();
		switch(tipo) {
		case "STRING":
			if(random.getPossibilidadesString().size() == 0) {
				if(random.getPossibilidadesInt().size() != 0) {
				error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_INT);
				}
				else {
				error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_BOOL);	
				}
				
			}
			break;
		case "BOOL":
			if(random.getPossibilidadesBool().size() == 0) {
				if(random.getPossibilidadesInt().size() != 0) {
					error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_INT);
					}
					else {
					error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_STRING);	
					}				
			}
			break;
		case "INT":
			if(random.getPossibilidadesInt().size() == 0) {
				if(random.getPossibilidadesString().size() != 0) {
					error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_STRING);
					}
					else {
					error("Elementos aleatórios não consistentes com tipo da variável", PlayLangPackage.Literals.RANDOM__POSSIBILIDADES_BOOL);	
					}				
			}
			break;
		}
	}
	
	@Check 
	public void checkAtribuicaoType(Atribuicao atribuicao) {
		Expressao exp = atribuicao.getExpressao();
		switch(atribuicao.getId().getTipo()) {
		case "STRING":
				if(atribuicao.getString() != null) {
					return;
				}
				//A linguagem não tem suporte a concatenação de strings por operadores,então uma string deve ser o único elemento de uma expressão para uma atribuição
				if(exp.getTermos().size()==1 && exp.getTermos().get(0).getFatores().size()==1 && exp.getTermos().get(0).getFatores().get(0).getParcela().getExp() !=null)
						 {
					if(!checkRExpressionType(exp.getTermos().get(0).getFatores().get(0).getParcela().getExp()).equals("STRING")) {
						error("A atribuição deve ser de tipo STRING", PlayLangPackage.Literals.ATRIBUICAO__EXPRESSAO);
					}
				}
				else {
					error("A atribuição deve ser de tipo STRING", PlayLangPackage.Literals.ATRIBUICAO__EXPRESSAO);
				}
				break;
				
		case	"BOOL":
			if(atribuicao.getString() != null) {
				error("Atribuição de bool não pode ser uma string",PlayLangPackage.Literals.ATRIBUICAO__STRING);
				return;
			}
				for( var termoL:exp.getTermos()) {
					for(var fatorL:termoL.getFatores()) {
						if(fatorL.getParcela().getExp() != null) {
							String tipo = checkRExpressionType(fatorL.getParcela().getExp());
							//Se um dos tipos das expressões relacionais que compôem a expressão não são bool, a expressão está incorreta
							if(!tipo.equals("BOOL")) {
								error("A atribuição deve ser de tipo BOOL", PlayLangPackage.Literals.ATRIBUICAO__EXPRESSAO);
							}
						}
					}
				}
			
				break;
				
				
		case	"INT":
			if(atribuicao.getString() != null) {
				error("Atribuição de int não pode ser uma string",PlayLangPackage.Literals.ATRIBUICAO__STRING);
				return;
			}
			if(exp.getTermos().size()==1 && exp.getTermos().get(0).getFatores().size()==1 && exp.getTermos().get(0).getFatores().get(0).getParcela().getExp() !=null)
			 {
		if(!checkRExpressionType(exp.getTermos().get(0).getFatores().get(0).getParcela().getExp()).equals("INT")) {
			error("A atribuição deve ser de tipo INT", PlayLangPackage.Literals.ATRIBUICAO__EXPRESSAO);
		}
	}
	else {
		error("A atribuição deve ser de tipo INT", PlayLangPackage.Literals.ATRIBUICAO__EXPRESSAO);
	}
				break;
		}
		}
	}



